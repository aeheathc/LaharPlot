<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on June, 10  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE><CODE>sdts++</CODE> Library: </TITLE>

<META NAME="description" CONTENT="<CODE>sdts++</CODE> Library: ">
<META NAME="keywords" CONTENT="<CODE>sdts++</CODE> Library: ">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC_Top"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1><CODE>sdts++</CODE> Library</H1></P><P>

<A NAME="IDX1"></A>
Programmers can use sdts++ classes to read and write Spatial Data
Transfer Standard (SDTS) files.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC1">1. Introduction</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">About SDTS++</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC2">2. Installing</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to build and install sdts++</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC5">3. Using</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to use sdts++</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC37">4. Credits</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">The guilty parties</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC38">5. Legalese</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Text for those with JDs</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC39">6. Support</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Where to go to get sdts++ related help</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC40">7. Bibliography</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Some recommended reading</TD></TR>
</TABLE>

<br>
<TABLE BORDER=0 CELLSPACING=0>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC41">Concept Index</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<HR SIZE=1>
<A NAME="SEC1"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<A NAME="Introduction"></A>
<H1> 1. Introduction </H1>
<!--docid::SEC1::-->
<P>

<A NAME="IDX2"></A>
</P><P>

SDTS++ is a C++ toolkit for reading and writing SDTS datasets.
Application developers can use SDTS++ library classes to work with the
logical structure of these datasets without having to worry about the
physical details of each dataset.
</P><P>

<A NAME="IDX3"></A>
<A NAME="IDX4"></A>
Please note that this document assumes that you are not only familiar
with C++, but with the Standard C++ Library; and, more importantly,
you are knowledgeable with using the Standard Template Library (STL).
</P><P>

<A NAME="Installing"></A>
<HR SIZE="6">
<A NAME="SEC2"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC1"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC3"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 2. Installing </H1>
<!--docid::SEC2::-->
<P>

<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
</P><P>

Here we describe how to build and install sdts++ for both UNIX and Windows.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC3">2.1 Installing for Windows</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Installing for Windows using Visual C++</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC4">2.2 Installing for UNIX</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Installing for UNIX and UNIX-like systems</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Windows"></A>
<HR SIZE="6">
<A NAME="SEC3"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC4"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.1 Installing for Windows </H2>
<!--docid::SEC3::-->
<P>

So far, the only Windows compilers that have been exercised on
<CODE>sdts++</CODE> have been Visual C++ 6.0 and cygwin's gcc.  Building for
the latter compiler is easy; just follow the UNIX build section
instructions.
</P><P>

<OL>
<LI>
Create or open a workspace
<P>

<LI>
Add the VC++ project file "Windows/sdtsxx/sdtsxx.dsp" to the workspace
<P>

<LI>
Build the project
<P>

<LI>
You're done!
<P>

</OL>
<P>

Alternatively, you can use the Boost bjam build utility.
</P><P>

<OL>
<LI>edit <TT>`Jamrules'</TT> and <TT>`boost-build.jam'</TT> to reflect
location of Boost.  The Boost C++ library can be fetched from
<A HREF="http://www.boost.org/">http://www.boost.org/</A>
<P>

<LI>install the bjam executable somewhere in your $PATH.  It can be
gotten from <A HREF="http://www.boost.org/tools/build/index.html#Jam">http://www.boost.org/tools/build/index.html#Jam</A>.
<P>

<LI><CODE>cd sdts++; bjam -sTOOLS=msvc</CODE>
<P>

<LI><CODE>cd ../sysutils; bjam -sTOOLS=msvc</CODE>
<P>

</OL>
<P>

Debug and release binaries for the sdts++ and dependant sysutils
libraries will be in the <TT>`sdts++/bin'</TT> and <TT>`sysutils/bin'</TT>
directory hierarchies, respectively.  Build behavior can be modified
by editing the <TT>`Jamfile'</TT>s located in <TT>`sdts++'</TT> and
<TT>`sysutil'</TT>.  There also exists a <TT>`Jamfile'</TT> for the test
harnasses found in <TT>`tests'</TT>.
</P><P>

Note that compilers are specified via <VAR>TOOLS</VAR> and support not just
Microsoft Visual C++ and GNU g++.  Please see the Boost web site for a
canonical list of supported compilers. 
</P><P>

<A NAME="UNIX"></A>
<HR SIZE="6">
<A NAME="SEC4"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC3"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 2.2 Installing for UNIX </H2>
<!--docid::SEC4::-->
<P>

<OL>
<LI>
Run the configure script.
<P>

Please note that the configure script will try and use the GNU
C/C++ compiler if it finds it.  You can over-ride the configure script
by specifying the C and/or C++ compilers by setting the CC and CXX
environment variables, respectively.  For example, to prefer to use
<KBD>/usr/bin/CC</KBD> as the C++ compiler, invoke the script like this:
</P><P>

        <KBD>% env CXX=/usr/bin/CC ./configure</KBD>
</P><P>

<LI>
Run make to build the library
<P>

Note that you will need to use GNU make.  It can be fetched via
anonymous ftp from <A HREF="http://www.gnu.org/software/make">http://www.gnu.org/software/make</A>.
</P><P>

<LI>
Optionally, run `make check' to build and run test programs
<P>

<LI>
<KBD>make install</KBD> to copy the header and library files to the target
directories.
<P>

</OL>
<P>

By default, these directories will be <TT>`/usr/local/include/sdts++'</TT>
for the header files and <TT>`/usr/local/lib/'</TT> for the library.  You
can change these target directories by using the parameter
<KBD>--prefix=/my/target/dir</KBD> when invoking the configure script.  If
you just want the <EM>binaries</EM> to go to a different place (and thus
have the headers go to a default location), then you can specify
<KBD>--exec-prefix=/my/target/binary/dir</KBD> instead.
</P><P>

Note that you can also use bjam to build the library on most UNIX
platforms.  Simply follow the instructions found in the previous
section using, say, "-sTOOLS=gcc" to specify the GNU g++ compiler.
Again, please consult the Boost bjam documentation for more information.
</P><P>

<A NAME="Using"></A>
<HR SIZE="6">
<A NAME="SEC5"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC4"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC2"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 3. Using </H1>
<!--docid::SEC5::-->
<P>

<A NAME="IDX9"></A>
The SDTS++ library is comprised of four major components, or
"sub-systems".  These are the Container, I/O, Builder, and Logical
sub-systems.  The Container subsystem is used to hold SDTS data.  The
I/O sub-system, naturally, is responsible for reading and writing SDTS
data -- it relies on Container objects to hold data that is either
read in or to be written out.  The Builder contains convenience
classes for translating SDTS data at a higher level than provided by
raw Container classes.  Similarly, the Logical classes contain
convenience classes for some SDTS spatial types.  The next sections
will discuss each sub-system in turn.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC6">3.1 Container Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">About modules, records, fields, and subfields</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC12">3.2 I/O Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to read and write sdts++ containers</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC31">3.3 Builder Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Convenience classes to read and write modules</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC36">3.4 Logical Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Experimental classes for holding spatial data</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Container Classes"></A>
<HR SIZE="6">
<A NAME="SEC6"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.1 Container Classes </H2>
<!--docid::SEC6::-->
<P>

The SDTS transfer model contains several logical constructs for
holding data.  They are: modules, which contain records, which contain
fields, which contain subfields.  SDTS++ provides classes that
correspond to these logical constructs.  The table below depicts these
classes and their respective relationships to the SDTS transfer model.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        SDTS            SDTS++

        Module          sc_Module
        Record          sc_Record
        Field           sc_Field
        Subfield        sc_Subfield
</pre></td></tr></table></P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Detailed descriptions for all the containers</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Container interface"></A>
<HR SIZE="6">
<A NAME="SEC7"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC8"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.1.1 Container interface </H3>
<!--docid::SEC7::-->
        
All SDTS++ containers (i.e., sc_Module, sc_Record, and sc_Field) have
the following member functions, which are provided by STL (since they
are implemented as STL containers) <CITE>Musser &#38; Saini 1996</CITE>:
<P>

<DL COMPACT>

<A NAME="IDX10"></A>
<DT><CODE>X()</CODE>
<DD><A NAME="IDX11"></A>
default constructor
<P>

<A NAME="IDX12"></A>
<DT><CODE>X(a)</CODE>
<DD><A NAME="IDX13"></A>
constructor
<P>

<A NAME="IDX14"></A>
<DT><CODE>X u(a)</CODE>
<DD><A NAME="IDX15"></A>
copy constructor
<P>

<A NAME="IDX16"></A>
<DT><CODE>~X()</CODE>
<DD><A NAME="IDX17"></A>
destructor
<P>

<A NAME="IDX18"></A>
<DT><CODE>a.begin()</CODE>
<DD><A NAME="IDX19"></A>
returns an iterator, or const iterator if a is constant
<P>

<A NAME="IDX20"></A>
<DT><CODE>a.end()</CODE>
<DD><A NAME="IDX21"></A>
returns an iterator that points just one element beyond the last element
<P>

<A NAME="IDX22"></A>
<DT><CODE>a.rbegin()</CODE>
<DD><A NAME="IDX23"></A>
returns a reverse iterator
<P>

<A NAME="IDX24"></A>
<DT><CODE>a.rend()</CODE>
<DD><A NAME="IDX25"></A>
returns a reverse iterator that points to just one element before the first
<P>

<A NAME="IDX26"></A>
<DT><CODE>a.size()</CODE>
<DD><A NAME="IDX27"></A>
returns number of elements
<P>

<A NAME="IDX28"></A>
<DT><CODE>a.max_size()</CODE>
<DD><A NAME="IDX29"></A>
largest possible size()
<P>

<A NAME="IDX30"></A>
<DT><CODE>a.empty()</CODE>
<DD><A NAME="IDX31"></A>
returns true if there are no elements
<P>

<A NAME="IDX32"></A>
<DT><CODE>r = a</CODE>
<DD><A NAME="IDX33"></A>
assigns contents of a to r
<P>

<A NAME="IDX34"></A>
<DT><CODE>a.swap(b)</CODE>
<DD><A NAME="IDX35"></A>
swap the two container contents
<P>

</DL>
<P>

There are other member functions provided by the STL list
implementation that we used for the SDTS++ containers.  Please consult
an STL resource for more information on how to use STL containers.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC8">3.1.1.1 sc_Module</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">SDTS module container</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC9">3.1.1.2 sc_Record</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">SDTS record container</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">SDTS field container</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">SDTS subfield container</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="sc_Module"></A>
<HR SIZE="6">
<A NAME="SEC8"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC9"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.1.1.1 sc_Module </H4>
<!--docid::SEC8::-->
<P>

This class is analagous to an SDTS module.  Like an SDTS module, it
contains zero or more records.
</P><P>

<A NAME="sc_Record"></A>
<HR SIZE="6">
<A NAME="SEC9"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC8"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC10"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.1.1.2 sc_Record </H4>
<!--docid::SEC9::-->
<P>

This class is equivalent to an SDTS record and is composed of sc_Field
objects.
</P><P>

<A NAME="sc_Field"></A>
<HR SIZE="6">
<A NAME="SEC10"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC9"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC11"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.1.1.3 sc_Field </H4>
<!--docid::SEC10::-->
<P>

This class corresponds to a SDTS field and is composed of sc_Subfield
objects.  In addition to the inherited STL member functions, some
additional functions have been added to allow an application to read
or change the field name and field mnemonic.  The following describes
these additional functions:
                                                       
<DL COMPACT>
<A NAME="IDX36"></A>
<DT><CODE>string const&#38; getName() const</CODE>
<DD><A NAME="IDX37"></A>
Returns the SDTS name of the field.  (if one has been set)
<P>

<A NAME="IDX38"></A>
<DT><CODE>string const&#38; getMnemonic() const</CODE>
<DD><A NAME="IDX39"></A>
Returns the SDTS mnemonic of the field.  (if one has been set)
 
<A NAME="IDX40"></A>
<DT><CODE>string const&#38; setName() const</CODE>
<DD><A NAME="IDX41"></A>
Returns the string parameter passed to the function and sets the
sc_field name to that value.  string const&#38; setName() const
<P>

<A NAME="IDX42"></A>
<DT><CODE>string const&#38; setMnemonic() const</CODE>
<DD><A NAME="IDX43"></A>
Returns the string parameter passed to the function and sets
the sc_field mnemonic to that value.
<P>

</DL>
<P>

<A NAME="sc_Subfield"></A>
<HR SIZE="6">
<A NAME="SEC11"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC10"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC7"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.1.1.4 sc_Subfield </H4>
<!--docid::SEC11::-->
<P>

This is the atomic class within the container sub-systems -- it is the
only non-container and is itself not comprised of any other classes.
An sc_Subfield contains the value of a SDTS subfield.
</P><P>

sc_Subfields defines the enumerator SubfieldType.  The following table
delineates these values and their corresponding meanings:
</P><P>

<DL COMPACT>
<A NAME="IDX44"></A>
<DT><CODE>is_A</CODE>
<DD><A NAME="IDX45"></A>
graphic, alphanumeric, or alphabetic characters.
<P>

<A NAME="IDX46"></A>
<DT><CODE>is_I</CODE>
<DD><A NAME="IDX47"></A>
implicit-point (integer)
<P>

<A NAME="IDX48"></A>
<DT><CODE>is_R</CODE>
<DD><A NAME="IDX49"></A>
explicit-point unscaled (fixed point, real)
<P>

<A NAME="IDX50"></A>
<DT><CODE>is_S</CODE>
<DD><A NAME="IDX51"></A>
explicit-point scaled (floating point, real)
<P>

<A NAME="IDX52"></A>
<DT><CODE>is_C</CODE>
<DD><A NAME="IDX53"></A>
character mode bitfield (binary in zero and one characters)
<P>

<A NAME="IDX54"></A>
<DT><CODE>is_B</CODE>
<DD><A NAME="IDX55"></A>
bitfield data
<P>

<A NAME="IDX56"></A>
<DT><CODE>is_BI8</CODE>
<DD><A NAME="IDX57"></A>
8 bit signed integer
<P>

<A NAME="IDX58"></A>
<DT><CODE>is_BI16</CODE>
<DD><A NAME="IDX59"></A>
16 bit signed integer
<P>

<A NAME="IDX60"></A>
<DT><CODE>is_BI24</CODE>
<DD><A NAME="IDX61"></A>
24 bit signed integer
<P>

<A NAME="IDX62"></A>
<DT><CODE>is_BI32</CODE>
<DD><A NAME="IDX63"></A>
32 bit signed integer
<P>

<A NAME="IDX64"></A>
<DT><CODE>is_BUI</CODE>
<DD><A NAME="IDX65"></A>
unsigned integer, length specified by implementation
<P>

<A NAME="IDX66"></A>
<DT><CODE>is_BUI8</CODE>
<DD><A NAME="IDX67"></A>
8 bit unsigned integer
<P>

<A NAME="IDX68"></A>
<DT><CODE>is_BUI16</CODE>
<DD><A NAME="IDX69"></A>
16 bit unsigned integer
<P>

<A NAME="IDX70"></A>
<DT><CODE>is_BUI24</CODE>
<DD><A NAME="IDX71"></A>
24 bit unsigned integer
<P>

<A NAME="IDX72"></A>
<DT><CODE>is_BUI32</CODE>
<DD><A NAME="IDX73"></A>
32 bit unsigned integer
<P>

<A NAME="IDX74"></A>
<DT><CODE>is_BFP32</CODE>
<DD><A NAME="IDX75"></A>
32 bit floating point real
<P>

<A NAME="IDX76"></A>
<DT><CODE>is_BFP64</CODE>
<DD><A NAME="IDX77"></A>
64 bit floating point real
<P>

</DL>
<P>

The mapping from SDTS types to C++ is as follows:
   
<DL COMPACT>
<DT><CODE>A</CODE>
<DD>string
<P>

<DT><CODE>I</CODE>
<DD>long
<P>

<DT><CODE>R,S</CODE>
<DD>double
<P>

<DT><CODE>C</CODE>
<DD>not implemented
<P>

<DT><CODE>BUI</CODE>
<DD>unsigned long
<P>

<DT><CODE>BI8, BI16, BI24, BI32</CODE>
<DD>long
<P>

<DT><CODE>BUI8, BUI16, BUI24, BUI32</CODE>
<DD>unsigned long
<P>

<DT><CODE>BFP32, BFP64</CODE>
<DD>double
<P>

</DL>
     
<P>

The sc_Subfield class has the following members:
</P><P>

<DL COMPACT>

<A NAME="IDX78"></A>
<DT><CODE>sc_Subfield( )</CODE>
<DD><A NAME="IDX79"></A>
<P>

<A NAME="IDX80"></A>
<DT><CODE>sc_Subfield( sc_Subfield const&#38; right)</CODE>
<DD><A NAME="IDX81"></A>
<P>

<A NAME="IDX82"></A>
<DT><CODE>~sc_Subfield()</CODE>
<DD><A NAME="IDX83"></A>
<P>

<A NAME="IDX84"></A>
<DT><CODE>sc_Subfield&#38; operator=(sc_Subfield const&#38; right)</CODE>
<DD><A NAME="IDX85"></A>
<P>

<A NAME="IDX86"></A>
<DT><CODE>bool operator==(sc_Subfield const&#38; right) const</CODE>
<DD><A NAME="IDX87"></A>
<P>

        This returns true if both subfields have the same name,
        mnemonic, type, and value.
</P><P>

<A NAME="IDX88"></A>
<DT><CODE>bool operator!=(sc_Subfield const&#38; right) const</CODE>
<DD><A NAME="IDX89"></A>
<P>

        inverse of operator==()
</P><P>

<A NAME="IDX90"></A>
<DT><CODE>SubfieldType getSubfieldType() const</CODE>
<DD><A NAME="IDX91"></A>
<P>

        Returns the subfield data type of the data in the sc_Subfield
        object.  The return value of SubfieldType is an enumerated
        data type that describes the type as one of the types listed
        above.
</P><P>

<A NAME="IDX92"></A>
<DT><CODE>string const&#38; getName() const</CODE>
<DD><A NAME="IDX93"></A>
<P>

        Returns the SDTS name of the subfield.
</P><P>

<A NAME="IDX94"></A>
<DT><CODE>string const&#38; getMnemonic() const</CODE>
<DD><A NAME="IDX95"></A>
<P>

        Returns the SDTS mnemonic of the subfield.
</P><P>

<A NAME="IDX96"></A>
<DT><CODE>string const&#38; setName(string const&#38; name)</CODE>
<DD><A NAME="IDX97"></A>
<P>

        sets the sc_subfield name to the given string and returns it
</P><P>

<A NAME="IDX98"></A>
<DT><CODE>string const&#38; setMnemonic(string const&#38; mnem)</CODE>
<DD><A NAME="IDX99"></A>
<P>

        sets the sc_subfield mnemnonic to the given string and returns it
</P><P>

</DL>
<P>

These functions are used to fetch a subfield's value; there is one
function for each of the canonical subfield types.  Each will return
'false' if the subfield contains an incompatible value.  For example, if
the subfield is a string (i.e., <CODE>is_A</CODE>) and its <CODE>getBI32()</CODE>
function is invoked, then that call will fail.
</P><P>

<DL COMPACT>
<A NAME="IDX100"></A>
<DT><CODE>bool getA(string&#38; val) const</CODE>
<DD><A NAME="IDX101"></A>
<A NAME="IDX102"></A>
<DT><CODE>bool getI(long&#38; val) const</CODE>
<DD><A NAME="IDX103"></A>
<A NAME="IDX104"></A>
<DT><CODE>bool getR(double&#38; val) const</CODE>
<DD><A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<DT><CODE>bool getS(double&#38; val) const</CODE>
<DD><A NAME="IDX107"></A>
<A NAME="IDX108"></A>
<DT><CODE>bool getC(string&#38; val) const</CODE>
<DD><A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<DT><CODE>bool getBI8(long&#38; val) const</CODE>
<DD><A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<DT><CODE>bool getBI16(long&#38; val) const</CODE>
<DD><A NAME="IDX113"></A>
<A NAME="IDX114"></A>
<DT><CODE>bool getBI24(long&#38; val) const</CODE>
<DD><A NAME="IDX115"></A>
<A NAME="IDX116"></A>
<DT><CODE>bool getBI32(long&#38; val) const</CODE>
<DD><A NAME="IDX117"></A>
<A NAME="IDX118"></A>
<DT><CODE>bool getBUI8(unsigned long&#38; val) const</CODE>
<DD><A NAME="IDX119"></A>
<A NAME="IDX120"></A>
<DT><CODE>bool getBUI16(unsigned long&#38; val) const</CODE>
<DD><A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<DT><CODE>bool getBUI24(unsigned long&#38; val) const</CODE>
<DD><A NAME="IDX123"></A>
<A NAME="IDX124"></A>
<DT><CODE>bool getBUI32(unsigned long&#38; val) const</CODE>
<DD><A NAME="IDX125"></A>
<A NAME="IDX126"></A>
<DT><CODE>bool getFP32(double&#38; val) const</CODE>
<DD><A NAME="IDX127"></A>
<A NAME="IDX128"></A>
<DT><CODE>bool getFP64(double&#38; val) const</CODE>
<DD><A NAME="IDX129"></A>
</DL>
<P>

Naturally each of the previous functions has a corresponding inverse
to set a value for a given type.  Note that after a particular set
function is used, the subfield's type is set to that.  E.g., invoking
<SAMP>`setI()'</SAMP> will set that subfield's type to <SAMP>`is_I'</SAMP>.
</P><P>

<DL COMPACT>
<A NAME="IDX130"></A>
<DT><CODE>void setA(string const&#38; val)</CODE>
<DD><A NAME="IDX131"></A>
<A NAME="IDX132"></A>
<DT><CODE>void setI(long val)</CODE>
<DD><A NAME="IDX133"></A>
<A NAME="IDX134"></A>
<DT><CODE>void setR(double val)</CODE>
<DD><A NAME="IDX135"></A>
<A NAME="IDX136"></A>
<DT><CODE>void setS(double val)</CODE>
<DD><A NAME="IDX137"></A>
<A NAME="IDX138"></A>
<DT><CODE>void setC(string const&#38; val)</CODE>
<DD><A NAME="IDX139"></A>
<A NAME="IDX140"></A>
<DT><CODE>void setBI8(long val)</CODE>
<DD><A NAME="IDX141"></A>
<A NAME="IDX142"></A>
<DT><CODE>void setBI16(long val)</CODE>
<DD><A NAME="IDX143"></A>
<A NAME="IDX144"></A>
<DT><CODE>void setBI24(long val)</CODE>
<DD><A NAME="IDX145"></A>
<A NAME="IDX146"></A>
<DT><CODE>void setBI32(long val)</CODE>
<DD><A NAME="IDX147"></A>
<A NAME="IDX148"></A>
<DT><CODE>void setBUI8(unsigned long val)</CODE>
<DD><A NAME="IDX149"></A>
<A NAME="IDX150"></A>
<DT><CODE>void setBUI16(unsigned long val)</CODE>
<DD><A NAME="IDX151"></A>
<A NAME="IDX152"></A>
<DT><CODE>void setBUI24(unsigned long val)</CODE>
<DD><A NAME="IDX153"></A>
<A NAME="IDX154"></A>
<DT><CODE>void setBUI32(unsigned long val)</CODE>
<DD><A NAME="IDX155"></A>
<A NAME="IDX156"></A>
<DT><CODE>void setFP32(double val)</CODE>
<DD><A NAME="IDX157"></A>
<A NAME="IDX158"></A>
<DT><CODE>void setFP64(double val)</CODE>
<DD><A NAME="IDX159"></A>
</DL>
<P>

<A NAME="I/O Classes"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC11"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.2 I/O Classes </H2>
<!--docid::SEC12::-->
<P>

The I/O subsystem is responsible for reading and writing SDTS
transfers.  The I/O subsystem has two major parts: readers and
writers.  Readers are used to read in SDTS data and store them into
SDTS++ container objects.  Writers are the inverse of readers; they
take data found in SDTS++ container objects and write them out to SDTS
transfers.  We'll discuss readers and writers in the following sections.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC13">3.2.1 Readers</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Used to read SDTS data into containers</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC20">3.2.2 Writers</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Used to write SDTS modules from containers</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Readers"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC14"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC6"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.1 Readers </H3>
<!--docid::SEC13::-->
<P>

There are two vital components to reading SDTS data in SDTS++: readers
and reader iterators.  Readers are attached to a input file stream
that is open onto a valid SDTS 8211 module file.  Then one or more
reader iterators are then, in turn, attached to that reader.  The user
then uses these iterators to fetch records in a given sc_Record
object, move to the next record, and to determine when there are no
more records to be read.  
</P><P>

Readers are passive entites from a user's perspective; all the real
work is done via iterators.  The user interacts with a reader through
one of its iterators and never directly through a reader.  The
iterator works with its reader behind the scene to fetch records, move
forward to the next record, and to report that there are no more records.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC14">3.2.1.1 Reader and Reader Iterator Base Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC19">3.2.1.6 Example</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Reader and Reader Iterator Base Classes"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC15"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.1 Reader and Reader Iterator Base Classes </H4>
<!--docid::SEC14::-->
<P>

We recognized early on in SDTS++'s design process that there might
conceivably exist alternative physical forms for an SDTS dataset.  To
this end, we designed abstract base classes for a "generalized" reader
and reader iterator.  These are, respectively, sc_Reader and
sc_ForwardIterator.
</P><P>

<A NAME="sio_Reader"></A>
<HR SIZE="6">
<A NAME="SEC15"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC14"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC16"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.2 sio_Reader </H4>
<!--docid::SEC15::-->
<P>

sio_Reader declares the following interface:
</P><P>

<DL COMPACT>
<A NAME="IDX160"></A>
<DT><CODE>sio_Reader( istream &#38; is )</CODE>
<DD><A NAME="IDX161"></A>
<P>

            Initializes the reader for the given stream.  (Note that
            the current implementation differs from this.  It has a
            second parameter that takes a pointer to a converter
            container.  This is wrong and will be changed in a
            subsequent implementation.)
</P><P>

<A NAME="IDX162"></A>
<DT><CODE>virtual ~sio_Reader() = 0;</CODE>
<DD><A NAME="IDX163"></A>
</DL>
<P>

        
<A NAME="sio_ForwardIterator"></A>
<HR SIZE="6">
<A NAME="SEC16"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC15"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC17"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.3 sio_ForwardIterator </H4>
<!--docid::SEC16::-->
<P>

Again, the sio_ForwardIterator provides the means of navigating through
SDTS records, to retrieve record contents, and to report that there
are no more records in the corresponding reader's associated SDTS
module.  As its name suggests, it is only possible to move forward
from record to record.  Iterating "backwards" or random record access
are not supported by this class.
</P><P>

sio_ForwardIterator declares the following interface:
</P><P>

<DL COMPACT>
<A NAME="IDX164"></A>
<DT><CODE>virtual ~sio_ForwardIterator( )</CODE>
<DD><A NAME="IDX165"></A>
<P>

<A NAME="IDX166"></A>
<DT><CODE>virtual bool get( sc_Record&#38; record )  = 0;</CODE>
<DD><A NAME="IDX167"></A>
<P>

        Returns true if get successful, else false.  If successful,
        the given record will be filled with the corresponding
        contents of the current SDTS module record.
</P><P>

<A NAME="IDX168"></A>
<DT><CODE>virtual void operator++() = 0;</CODE>
<DD><A NAME="IDX169"></A>
<P>

        Moves the iterator forward to the next SDTS record.
</P><P>

<A NAME="IDX170"></A>
<DT><CODE>virtual bool done() const = 0;</CODE>
<DD><A NAME="IDX171"></A>
<P>

        Returns non-zero if no more data or reader is in error state.
</P><P>

<A NAME="IDX172"></A>
<DT><CODE>virtual operator void*() const = 0;</CODE>
<DD><A NAME="IDX173"></A>
<P>

        Returns a non-null void * if there's still more data to read.
</P><P>

</DL>
<P>

<A NAME="sio_8211Reader"></A>
<HR SIZE="6">
<A NAME="SEC17"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC16"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC18"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.4 sio_8211Reader </H4>
<!--docid::SEC17::-->
<P>

<CODE>sio_8211Reader</CODE>, as dictated by its parent <CODE>sio_Reader</CODE>,
manages the reading of SDTS records from an input stream.  However,
there is one issue that it has to address that is peculiar to ISO 8211
and to SDTS.  That is, <CODE>sio_8211Reader</CODE> needs some help to properly
translate binary SDTS data.
</P><P>

The problem is that ISO 8211 can only describe a binary subfield by
its width in bits.  For example a valid ISO 8211 binary description
would be <SAMP>`B(32)'</SAMP>, which means a subfield that is binary and has 32
bits.  Fair enough, but what exactly do those bits represent?  A 32
bit signed integer?  Unsigned?  Is it a 32 bit floating point field?
</P><P>

SDTS should have descriptions for exactly how to translate these
binary values.  Where these descriptions are depend on the binary
value in question.  For example, spatial data binary types are
described in the IREF module.  Here's a sample dump from an IREF
module:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>IREF : INTERNAL SPATIAL REFERENCE
        MODN : IREF
        RCID : 1
        SATP : 2-TUPLE
        XLBL : EASTING
        YLBL : NORTHING
        HFMT : BI32
        SFAX : 0.01
        SFAY : 0.01
        XORG : 0
        YORG : 0
        XHRS : 2.54
        YHRS : 2.54
</pre></td></tr></table></P><P>

The <SAMP>`HFMT'</SAMP> subfield describes the spatial data format for SDTS
modules.  Here you can see that spatial data are represented as
<SAMP>`BI32'</SAMP>.
</P><P>

There exist a set of classes that we call "converters" that are
responsible for translating data between raw 8211 and SDTS subfields.
Normally they'd be a hidden implementation detail.  Unfortunately
we've had to expose this detail a bit to work around this problem of
properly translating binary data.
</P><P>

The second <CODE>sio_8211Reader</CODE> constructor argument is optional.  You
may provide it a map of SDTS subfield mnemonics to converters as a
"hint" to the reader for any binary data it might encounter.  If the
reader runs across a binary field, it will search the converter map you
gave it for the mnemonic for that binary field; it will use the
converter you specify if it finds a match.  If it can't find a match,
then the read will fail.
</P><P>

So, to continue from the preceding example, we'd set up a reader for
spatial data given that we want to use a BI32 converter this way:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><CODE>
        // see "sdts++/io/sio_ConverterFactory.h" for convenient converter builder
        converter_dictionary converters;


        // ask the canonical instance of the converter factor to return
        // a pointer to an sio_8211Converter_BI32 object

        converters["X"] = sio_ConverterFactory::instance()->get( "BI32" );
        converters["Y"] = sio_ConverterFactory::instance()->get( "BI32" );
        
        sio_8211Reader  reader( my_ddf_stream, &#38;converters );
</CODE>
</pre></td></tr></table></P><P>

So if "reader" happens across a binary subfield with either the
subfield mnemonics of "X" or "Y", it will use our <CODE>BI32</CODE> converter,
<SAMP>`bi32_converter'</SAMP>.
</P><P>

sio_8211Reader declares the following public members:
</P><P>

<DL COMPACT>
<A NAME="IDX174"></A>
<DT><CODE>sio_8211Reader( istream &#38; is,  const map&#60;string, sio_8211Converter*&#62; * converters = 0)</CODE>
<DD><A NAME="IDX175"></A>
<P>

        Constructor taking arguments for input stream containing a
        valid SDTS module, and optionally a pointer to binary
        converter hints.
</P><P>

<A NAME="IDX176"></A>
<DT><CODE>~sio_8211Reader()</CODE>
<DD><A NAME="IDX177"></A>
<P>

<A NAME="IDX178"></A>
<DT><CODE>sio_8211Schema &#38; getSchema()</CODE>
<DD><A NAME="IDX179"></A>
<P>

        Returns the schema that the reader built from the module's
        DDR.  (This is a test member function that allowed us to read
        existing SDTS modules and write them again using SDTS++.
        Please see the section on sio_Writer for more information on
        schemas.)
</P><P>

</DL>
<P>

<A NAME="8211 Forward Iterator"></A>
<HR SIZE="6">
<A NAME="SEC18"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC17"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC19"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.5 8211 Forward Iterator </H4>
<!--docid::SEC18::-->
<P>

sio_8211ForwardIterator declares the following public members:
</P><P>

<DL COMPACT>

<A NAME="IDX180"></A>
<DT><CODE>sio_8211ForwardIterator( sio_8211Reader&#38; reader )</CODE>
<DD><A NAME="IDX181"></A>
<P>

        Constructor that attaches the iterator to the given reader.
</P><P>

<A NAME="IDX182"></A>
<DT><CODE>bool get( sc_Record&#38; record )</CODE>
<DD><A NAME="IDX183"></A>
<P>

        Fills the given record with the contents of the current SDTS
        record.  Returns false if there were problems reading that
        record.
</P><P>

<A NAME="IDX184"></A>
<DT><CODE>void operator++()</CODE>
<DD><A NAME="IDX185"></A>
<P>

        Move on to the next SDTS record.
</P><P>

<A NAME="IDX186"></A>
<DT><CODE>bool done() const</CODE>
<DD><A NAME="IDX187"></A>
<P>

        Returns true if there are no more records.
</P><P>

<A NAME="IDX188"></A>
<DT><CODE>virtual operator void*() const</CODE>
<DD><A NAME="IDX189"></A>
<P>

        Is non-zero if there are still records to read and if there
        aren't any problems with the reader.
</P><P>

</DL>
<P>

<A NAME="Reader Example"></A>
<HR SIZE="6">
<A NAME="SEC19"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC18"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.1.6 Example </H4>
<!--docid::SEC19::-->
<P>

Please see <TT>`contrib/prsdts/prsdts.cpp'</TT> for sample
code used to read an SDTS module.
</P><P>

<A NAME="Writers"></A>
<HR SIZE="6">
<A NAME="SEC20"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC19"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC21"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.2.2 Writers </H3>
<!--docid::SEC20::-->
<P>

<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
Writers are the mechanisms for creating SDTS modules.  They operate by
writing the contents of a given container of SDTS data in a specific
physical format.  Different writers will support different formats.
Currently the only available writer emits proper ISO 8211 based SDTS
modules.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC23">3.2.2.3 Schemas</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC26">3.2.2.6 Repeating fields</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC27">3.2.2.7 A note about repeating binary fields</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC28">3.2.2.8 Support for permuted tags</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC29">3.2.2.9 Dropped leaders and directories</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC30">3.2.2.10 Example</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="sio_Writer"></A>
<HR SIZE="6">
<A NAME="SEC21"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC22"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.1 sio_Writer </H4>
<!--docid::SEC21::-->
<P>

Like the reader, <CODE>sio_Writer</CODE> is an abstract base class.  It is
intended to be a parent for any writers that emit SDTS modules in the
physical format of choice -- whether that be ISO 8211 or some other
physical representation.
</P><P>

(Please note that ISO 8211 is the only official physical format.
However, one could develop a writer that writes in some sort of plain
ASCII format, Hierarchical Data Format (HDF), etc.  In other words,
use the sio_Writer interface to provide some form of translator from
SDTS to another format.)
</P><P>

<CODE>sio_Writer</CODE>, unlike <CODE>sio_Reader</CODE>, does not have a
corresponding iterator.  Since a reader doesn't itself modify a module's
data, it's safe to have multiple iterators attached to it.  However, we
felt that the complexity inherent in keeping track of different
iterators for a given writer didn't buy us much.  Not only would we have
to implement some form of record locking, but we also recognized that
the majority of the time the writer would be used in a straightforward
sequential fashion.  That is, by the time a writer is brought into play,
the user typically would want to write out all the data in a single
straight shot.
</P><P>

Instead of using an iterator, the user will interact directly with a
writer.  The user will hand a writer an <CODE>sc_Record</CODE>, which it will
emit in the proper physical format to a corresponding output stream.
Subsequent records given to the writer will simply be concatenated to
any previous records.
</P><P>

sio_Writer declares the following interface:
</P><P>

<DL COMPACT>

<A NAME="IDX192"></A>
<DT><CODE>virtual ~sio_Writer() = 0</CODE>
<DD><A NAME="IDX193"></A>
<P>

<A NAME="IDX194"></A>
<DT><CODE>virtual bool put( sc_Record&#38; ) = 0</CODE>
<DD><A NAME="IDX195"></A>
<P>

        Will write the given record out to the stream.
</P><P>

<A NAME="IDX196"></A>
<DT><CODE>virtual bool good( ) const = 0</CODE>
<DD><A NAME="IDX197"></A>
<P>

        Returns true if the writer is in a usable state.
</P><P>

</DL>
<P>

<A NAME="sio_8211Writer"></A>
<HR SIZE="6">
<A NAME="SEC22"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC21"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC23"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.2 sio_8211Writer </H4>
<!--docid::SEC22::-->
<P>

<CODE>sio_8211Writer</CODE> is, as you might guess, a writer for emitting
proper 8211 encodings of SDTS data.  And, as with <CODE>sio_8211Reader</CODE>,
there are issues peculiar to 8211 that this class has to cope with.
</P><P>

That is, we want to write out a complete DDR before writing any DR's.
At one time we thought of a design that would modify the DDR as each
DR was written out -- any new fields that weren't already in the DDR
would be added on the fly.  We felt that not only would this exact a
terrible toll on performance, but it would add greatly to this class'
complexity.  So we decided to pay the price up front and write out a
complete DDR before writing any DRs.
</P><P>

The problem here is that the user has to give enough information to the
<CODE>sio_8211Writer</CODE> ahead of time for it to write out a proper DDR.
The mechanism for this is called a 'schema'.  This is a data structure
that contains all the field and subfield information that an
<CODE>sio_8211Writer</CODE> will need to not only write out that DDR, but to also
properly write out data for each DR.  We discuss schemas in more detail
later.
</P><P>

sio_8211Writer has the following public interface:
</P><P>

<DL COMPACT>

<A NAME="IDX198"></A>
<DT><CODE>sio_8211Writer( ofstream &#38; ofs, const char* title, sio_8211Schema const &#38; schema )</CODE>
<DD><A NAME="IDX199"></A>
<P>

<A NAME="IDX200"></A>
<DT><CODE>sio_8211Writer( ofstream &#38; ofs, const char* title )</CODE>
<DD><A NAME="IDX201"></A>
<P>

        Constructors that take arguments to an open file stream where
        the 8211 data will be written, a title to be used in the 8211 file
        identifier field, and a schema describing the field and subfield
        structures and the appropriate subfield converters.
</P><P>

<A NAME="IDX202"></A>
<DT><CODE>~sio_8211Writer()</CODE>
<DD><A NAME="IDX203"></A>
<P>

<A NAME="IDX204"></A>
<DT><CODE>void setFileTitle( const char* fn )</CODE>
<DD><A NAME="IDX205"></A>
<P>

        Used to set the ISO 8211 file title field.
</P><P>

<A NAME="IDX206"></A>
<DT><CODE>void setSchema( sio_8211Schema const &#38; schema )</CODE>
<DD><A NAME="IDX207"></A>
<P>

        Used to set the schema for the writer.
</P><P>

<A NAME="IDX208"></A>
<DT><CODE>bool emitDDR()</CODE>
<DD><A NAME="IDX209"></A>
  
        Writes the DDR to the "ofs" given in the constructor.
        Returns false if something went wrong.
<P>

<A NAME="IDX210"></A>
<DT><CODE>bool put( sc_Record&#38; record )</CODE>
<DD><A NAME="IDX211"></A>
<P>

        Writes the contents of the given record to the "ofs" given
        to the constructor.  Returns false if something went wrong.
</P><P>

<A NAME="IDX212"></A>
<DT><CODE>bool good( ) const;</CODE>
<DD><A NAME="IDX213"></A>
  
        Returns true if the writer can write a record and if the last
        operation worked ok.
<P>

<A NAME="IDX214"></A>
<DT><CODE>void reuseLeaderAndDirectory()</CODE>
<DD><A NAME="IDX215"></A>
<P>

The next <CODE>put()</CODE> will emit a special leader and a directory.  All
subsequent <CODE>put()</CODE> invocations will emit only field data areas --
the last leader and directory will be 're-used' to save space. (C.f.,
ISO/IEC 8211:1994(E), page 44, C.1.5.2, "repeating leaders and
directories").
</P><P>

<EM>PLEASE NOTE THAT THIS ASSUMES THAT ALL SUBSEQUENT RECORDS HAVE
IDENTICAL RECORD LENGTHS AND FORMATS.</EM>  The behavior of <CODE>put()</CODE> is
undefined for records that do not match the format found in the last
leader and directory.
</P><P>

</DL>
<P>

<A NAME="Schemas"></A>
<HR SIZE="6">
<A NAME="SEC23"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC22"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC24"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.3 Schemas </H4>
<!--docid::SEC23::-->
<P>

A schema, which is formally known in SDTS++ as sio_8211Schema, is an STL
container of <CODE>sio_8211FieldFormats</CODE>.  An <CODE>sio_8211FieldFormat</CODE>
contains information about an 8211 field.  It is also a container of
<CODE>sio_8211SubfieldFormats</CODE> -- <CODE>sio_8211Subfield</CODE>s describe,
naturally, 8211 subfields.  We will describe each of these in turn.
</P><P>

<A NAME="sio_8211FieldFormat"></A>
<HR SIZE="6">
<A NAME="SEC24"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC23"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC25"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.4 sio_8211FieldFormat </H4>
<!--docid::SEC24::-->
<P>

This class corresponds to an ISO 8211 DDR field format description.
</P><P>

<CODE>sio_8211FieldFormat</CODE> defines the following enumerators:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><CODE>
        typedef enum { elementary, 
                       vector, 
                       array, 
                       concatenated } data_struct_code;

        typedef enum { char_string, 
                       implicit_point, 
                       explicit_point, 
                       explicit_point_scaled, 
                       char_bit_string, 
                       bit_string, 
                       mixed_data_type } data_type_code;
</CODE>
</pre></td></tr></table></P><P>

sio_8211FieldFormat declares the following public members:
</P><P>

<DL COMPACT>

<A NAME="IDX216"></A>
<DT><CODE>sio_8211FieldFormat()</CODE>
<DD><A NAME="IDX217"></A>
<P>

<A NAME="IDX218"></A>
<DT><CODE>sio_8211FieldFormat( sio_8211FieldFormat const &#38; )</CODE>
<DD><A NAME="IDX219"></A>
<P>

<A NAME="IDX220"></A>
<DT><CODE>~sio_8211FieldFormat()</CODE>
<DD><A NAME="IDX221"></A>
<P>

<A NAME="IDX222"></A>
<DT><CODE>sio_8211FieldFormat&#38; operator=( sio_8211FieldFormat const &#38; )</CODE>
<DD><A NAME="IDX223"></A>
<P>

<A NAME="IDX224"></A>
<DT><CODE>data_struct_code getDataStructCode( ) const</CODE>
<DD><A NAME="IDX225"></A>
<P>

        Returns the data structure code; that is, whether it's an
        elementary, vector, array, or concatenated field.
</P><P>

<A NAME="IDX226"></A>
<DT><CODE>data_type_code getDataTypeCode( ) const</CODE>
<DD><A NAME="IDX227"></A>
<P>

        Returns the data type code; that is, whether it's a character
        string, integer, real, character bit string, a raw binary
        type, or it's a complex field comprised of subfields of mixed
        types.
</P><P>

<A NAME="IDX228"></A>
<DT><CODE>string const&#38; getTag( ) const</CODE>
<DD><A NAME="IDX229"></A>
<P>

        Returns the field tag.
</P><P>

<A NAME="IDX230"></A>
<DT><CODE>string const&#38;     getName( ) const</CODE>
<DD><A NAME="IDX231"></A>
<P>

        Returns the field name.
</P><P>

<A NAME="IDX232"></A>
<DT><CODE>char getFieldTerm( ) const</CODE>
<DD><A NAME="IDX233"></A>
<P>

        Returns the visible field terminator character.
</P><P>

<A NAME="IDX234"></A>
<DT><CODE>char getUnitTerm( ) const</CODE>
<DD><A NAME="IDX235"></A>
<P>

        Returns the visible unit terminator character.
</P><P>

<A NAME="IDX236"></A>
<DT><CODE>bool isRepeating() const</CODE>
<DD><A NAME="IDX237"></A>
<P>

        This indicates that this field has multiple instances in
        single record.  Although this is usually automatically handled
        by the writer, we need to tell the writer this explicitly in
        the case of binary repeating fields so that the proper set of
        extra parenthesis are placed around the field format string.
        The isRepeating state need not be set for non-binary fields.
</P><P>

<A NAME="IDX238"></A>
<DT><CODE>void setDataStructCode( data_struct_code )</CODE>
<DD><A NAME="IDX239"></A>
<P>

        Set the data structure code.
 
</P><P>

<A NAME="IDX240"></A>
<DT><CODE>void setDataTypeCode( data_type_code )</CODE>
<DD><A NAME="IDX241"></A>
<P>

        Set the data type code.
 
</P><P>

<A NAME="IDX242"></A>
<DT><CODE>void setTag( string const &#38; )</CODE>
<DD><A NAME="IDX243"></A>
<P>

        Set the field tag.
</P><P>

<A NAME="IDX244"></A>
<DT><CODE>void setName( string const&#38; )</CODE>
<DD><A NAME="IDX245"></A>
<P>

        Set the field name.
</P><P>

<A NAME="IDX246"></A>
<DT><CODE>void setFieldTerm( char )</CODE>
<DD><A NAME="IDX247"></A>
<P>

        Set the printable field terminator character.
</P><P>

<A NAME="IDX248"></A>
<DT><CODE>void setUnitTerm( char )</CODE>
<DD><A NAME="IDX249"></A>
        Set the printable unit terminator character
<P>

<A NAME="IDX250"></A>
<DT><CODE>void setIsRepeating( bool repeating )</CODE>
<DD><A NAME="IDX251"></A>
<P>

        Indicate that the field is repeating.  Again note that this is
        only necessary for binary repeating fields.
</P><P>

</DL>
<P>

<A NAME="sio_8211SubfieldFormat"></A>
<HR SIZE="6">
<A NAME="SEC25"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC24"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC26"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.5 sio_8211SubfieldFormat </H4>
<!--docid::SEC25::-->
    
This class contains specific subfield formatting information.
<P>

This class defines the following enumerators:
    
<CODE>
     typedef enum { A, I, R, S, C, B, X } type;
    
     typedef enum { fixed, variable } format;
</CODE>
    
This class declares the following members:
 
<DL COMPACT>

<A NAME="IDX252"></A>
<DT><CODE>sio_8211SubfieldFormat()</CODE>
<DD><A NAME="IDX253"></A>
    
<A NAME="IDX254"></A>
<DT><CODE>sio_8211SubfieldFormat( sio_8211SubfieldFormat const &#38; )</CODE>
<DD><A NAME="IDX255"></A>
    
<A NAME="IDX256"></A>
<DT><CODE>~sio_8211SubfieldFormat()</CODE>
<DD><A NAME="IDX257"></A>
    
<A NAME="IDX258"></A>
<DT><CODE>sio_8211SubfieldFormat&#38; operator=( sio_8211SubfieldFormat const &#38; )</CODE>
<DD><A NAME="IDX259"></A>
    
<A NAME="IDX260"></A>
<DT><CODE>string const&#38; getLabel() const</CODE>
<DD><A NAME="IDX261"></A>
    
<A NAME="IDX262"></A>
<DT><CODE>type getType() const</CODE>
<DD><A NAME="IDX263"></A>
    
<A NAME="IDX264"></A>
<DT><CODE>format getFormat() const</CODE>
<DD><A NAME="IDX265"></A>
    
<A NAME="IDX266"></A>
<DT><CODE>int getLength() const</CODE>
<DD><A NAME="IDX267"></A>
    
<A NAME="IDX268"></A>
<DT><CODE>char getDelimiter() const</CODE>
<DD><A NAME="IDX269"></A>
    
<A NAME="IDX270"></A>
<DT><CODE>sio_8211Converter const * getConverter() const</CODE>
<DD><A NAME="IDX271"></A>
    
<A NAME="IDX272"></A>
<DT><CODE>void setLabel( string const &#38; )</CODE>
<DD><A NAME="IDX273"></A>
    
<A NAME="IDX274"></A>
<DT><CODE>void setType( type )</CODE>
<DD><A NAME="IDX275"></A>
    
<A NAME="IDX276"></A>
<DT><CODE>void setFormat( format )</CODE>
<DD><A NAME="IDX277"></A>
    
<A NAME="IDX278"></A>
<DT><CODE>void setLength( int )</CODE>
<DD><A NAME="IDX279"></A>
<P>

        sets format to fixed as a side-effect
</P><P>

<A NAME="IDX280"></A>
<DT><CODE>void setDelimiter( char )</CODE>
<DD><A NAME="IDX281"></A>
<P>

        sets format to variable as a side-effect
</P><P>

<A NAME="IDX282"></A>
<DT><CODE>void setConverter( sio_8211Converter const * )</CODE>
<DD><A NAME="IDX283"></A>
<P>

</DL>
<P>

<A NAME="Repeating fields"></A>
<HR SIZE="6">
<A NAME="SEC26"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC25"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC27"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.6 Repeating fields </H4>
<!--docid::SEC26::-->
<P>

SDTS Part 3 section 6.4.1 describes using repeating fields as a way of
saving space in module files.  It works by having multiple field
instances stored in the same record.  This saves the space that would
be required by having a DR for each of these fields; the space savings
is derived from not writing out a leader and directory for each of
those records.
</P><P>

SDTS++ supports repeating fields.  To use repeating fields, just do
the following:
</P><P>

<OL>
<LI>
Set the <CODE>sio_8211FieldFormat</CODE> data structure code to an array
<P>

<LI>
 Place multiple instances of the field that corresponds to the
<CODE>sio_8211FieldFormat</CODE> into the sc_Record to be passed to
<CODE>sio_8211Writer::put()</CODE>.  The writer will automatically detect the
multiple fields and put them in the same record, updating the DR's
directory entries appropriately.
    
</OL>
<P>

Here's an example of setting up a schema for a repeating spatial
address field:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre><CODE>
       // you can also use sio_ConverterFactory to return one for you instead
       sio_8211Converter_I converter_I; // integer converter

       sio_8211Schema schema;

       schema.push_back( sio_8211FieldFormat() );

       sio_8211FieldFormat&#38;  field_format = schema.back();

       field_format.setDataStructCode( sio_8211FieldFormat::array );
       field_format.setDataTypeCode( sio_8211FieldFormat::implict_point );
       field_format.setName( "SPATIAL ADDRESS" );
       field_format.setTag( "SADR" );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "X" );
       field_format.back().setType( sio_8211SubfieldFormat::I );
       field_format.back().setConverter( &#38;converter_I );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "Y" );
       field_format.back().setType( sio_8211SubfieldFormat::I );
       field_format.back().setConverter( &#38;converter_I );
</CODE>
</pre></td></tr></table></P><P>

<A NAME="A note about repeating binary fields"></A>
<HR SIZE="6">
<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.7 A note about repeating binary fields </H4>
<!--docid::SEC27::-->
<P>

Unfortunately the above mechanism breaks down in the case of
binary repeating fields thanks to an inherent ISO 8211 limitation.
The nature of this problem and its workaround are detailed in this
section.
</P><P>

The left-most parenthesis of an ISO 8211 subfield format string cannot
be next to a repeating binary format.  So this is illegal:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        (B(32))
</pre></td></tr></table></P><P>

        (But, this is legal in the non-repeating case.)
</P><P>

The kludge as specified by the standard is to add another set of outer
parenthesis, like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        ((B(32)))
</pre></td></tr></table></P><P>

What's even worse, the Topological Vector Profile (TVP) allows for
variants of the above:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        ((2B(32)))
</pre></td></tr></table>[This specifies a variable field that comes in two 32-bit chunks.]
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>        (10(2B(32)))
</pre></td></tr></table></P><P>

[This specifies ten subfields of two 32-bit chunks.]
</P><P>

The DDR creation mechanism is pretty intelligent about generating the
field format strings.  It will count up like subfields (i.e., those
with identical types) and emit appropriate format text.  So, four
string subfields will generate "4A", which will be spliced
appropriately in the final format string.  Sadly, this general format
string making mechanism has difficulty generating proper repeating
binary format strings.
</P><P>

For example, consider a binary chunk (type '5' in 8211-speak) that has
two subfields 32 bits each.  With the default format string creating
mechanism, the format string would be "(2B(32))".  This doesn't have
the necessary extra outer parenthesis.  It _should_ be "((2B(32)))".
</P><P>

The fix for this was to check a few things after creating a complete
format string.  If the field format type was "binary string" and a
special "isRepeating" flag set, then the writer would know it had a
repeating binary field.  It'd then add the required extra set of
parenthesis.
</P><P>

That resolves repeating binary fields of the type "((nB(s)))".  's' is
the size, and that's given in the subfield type.  'n' are the number
of binary subfields, and we can easily count those.
</P><P>

Unfortunately, this only handles _variable_ length repeating binary
fields.  This mechanism does not handle the case of "(m(nB(s)))" where
'm' is the number of times the whole shebang is repeated.
</P><P>

So we had to _assume_ that most uses of binary repeating fields will
be variable.  SDTS++ does not accomodate binary fields of the type
"(m(nB(s)))".
</P><P>

The following source takes the above SADR example and changes it to
use binary repeating fields:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>       // you can also use sio_ConverterFactory to return one for you
       // instead as shown in the section on sio_Reader
       
       sio_8211Converter_BI32 converter_BI32; // 32 bit integer converter

       sio_8211Schema schema;

       schema.push_back( sio_8211FieldFormat() );

       sio_8211FieldFormat&#38;  field_format = schema.back();

       field_format.setDataStructCode( sio_8211FieldFormat::array );
       field_format.setDataTypeCode( sio_8211FieldFormat::bit_string );
       field_format.setName( "SPATIAL ADDRESS" );
       field_format.setTag( "SADR" );
       field_format.setIsRepeating( true ); // hint to writer to add
                                            // extra parenthesis for
                                            // binary repeating field --
                                            // note that this isn't
                                            // necessary for any other type
                                            // of repeating field

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "X" );
       field_format.back().setType( sio_8211SubfieldFormat::B );
       field_format.back().setLength( 32 );
       field_format.back().setConverter( &#38;converter_BI32 );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "Y" );
       field_format.back().setType( sio_8211SubfieldFormat::B );
       field_format.back().setLength( 32 );
       field_format.back().setConverter( &#38;converter_BI32 );
</pre></td></tr></table></P><P>

See also "sio_Writer_t"/main.cpp"`s build_binary_schema() for an example.
</P><P>

<A NAME="Support for permuted tags"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.8 Support for permuted tags </H4>
<!--docid::SEC28::-->
    
All ISO 8211 field tags correspond to SDTS field mnemonics with one
notable exception.  It is possible for there to be multiple instances
of an SDTS field that have different structures.  In that case, there
will be a DDR field entry for each of these fields.  The problem is
that they will have the _same_ tag.  Which means that finding the
correct tag to properly decode a field becomes difficult because there
is more than one tag to choose from.
<P>

The work-around the standard provides is to "permute" the field tags
by adding a single character.  Unfortunately this means that _all_
field tags have to have extra chracters so appended since ISO 8211
requires that all field tags be the same size.
</P><P>

[see section 6.1.2 in SDTS part 3]
</P><P>

SDTS++ does not have an automatic mechanism for dealing with tag
permutation.  That is, a writer will not scan a given schema and
permute tags when it notices that there is more than one field with
the same mnemonic, but with different structures.  This means that the
onus is entirely on the programmer to watch for and handle tag
permutation.
</P><P>

How to handle this?  It's easy but tedious.  First, each
sio_8211FieldFormat in the schema needs to have an extra, arbitrary
character added before handing that schema to the writer.  Second, use
field mnemonics with this extra character for each sc_Field you add to
the <CODE>sc_Record</CODE> given to the writer's <CODE>put()</CODE> call.  The
permuted tags will get written to the file like normal tags.
</P><P>

<A NAME="Dropped leaders and directories"></A>
<HR SIZE="6">
<A NAME="SEC29"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC28"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC30"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.9 Dropped leaders and directories </H4>
<!--docid::SEC29::-->
<P>

ISO 8211 has another space saving feature.  DR leaders and directories
can be dropped if they don't change from DR to DR -- the last leader
and directory will be used for all DR's.  [c.f., section 5.2.1.2 in
the 1993 ISO 8211 spec.]
</P><P>

The <CODE>sio_8211Writer</CODE> has a member function,
<CODE>reuseLeaderAndDirectory()</CODE>, that's used to tell it that the next
record will be the last one to have a leader and directory.  (And the
leader identifier field will have 'R' instead of 'D' to indicate that
dropped leaders and directories are in effect.)  All subsequent records
given to its put() function will be emitted without leaders and
directories.
</P><P>

Please note that this obviously assumes that the record structures <EM>DO
NOT CHANGE</EM>.  If they do, then the generated SDTS module file will
almost certainly be wrong.
</P><P>

<A NAME="Writer Example"></A>
<HR SIZE="6">
<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC13"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC20"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H4> 3.2.2.10 Example </H4>
<!--docid::SEC30::-->
<P>

See <TT>`tests/sio_Writer.cpp'</TT>" for example code.
</P><P>

<A NAME="Builder Classes"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.3 Builder Classes </H2>
<!--docid::SEC31::-->
<P>

Manually grinding through SDTS records for both reading and reading
can be tedious.  The onus is on the programmer to iterate module
records, pulling out field and subfield values.  Moreover, the
programmer has to know in which modules to look for binary converter
information, and when.  The builder classes offer some convenience in
record translation both to and from SDTS modules, and in providing
utilities for easily getting binary converter information.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC32">3.3.1 Builder SDTS Module Classes</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">SDTS module specific classes</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC33">3.3.2 Binary Converter Builder</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Determine dataset binary converters</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC34">3.3.3 sb_Directory</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Finding modules easily through CATD</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="sdts++.html#SEC35">3.3.4 sb_Accessor</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Quickly finding and reading modules</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Builder SDTS Module Classes"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.1 Builder SDTS Module Classes </H3>
<!--docid::SEC32::-->
<P>

For each SDTS module, with few exceptions, there exists a
corresponding class found in <TT>`sdts++/builder/'</TT> .  Each of these
builder module classes inherits from <CODE>sb_Module</CODE>, and so provide
these methods:
</P><P>

<DL COMPACT>
<A NAME="IDX284"></A>
<DT><CODE>void getMnemonic( string &#38; mnemonic )</CODE>
<DD><A NAME="IDX285"></A>
Return the module's mnemonic
<P>

<A NAME="IDX286"></A>
<DT><CODE>int getID() const</CODE>
<DD><A NAME="IDX287"></A>
Return the record ID for the current record
<P>

<A NAME="IDX288"></A>
<DT><CODE>void setID( int )</CODE>
<DD><A NAME="IDX289"></A>
Set the record ID for the current record
<P>

<A NAME="IDX290"></A>
<DT><CODE>bool getSchema( sio_8211Schema &#38; schema )</CODE>
<DD><A NAME="IDX291"></A>
Returns the schema for the current module; this is useful for
providing a <CODE>sio_8211Schema</CODE> to a <CODE>sio_Writer</CODE>.
<P>

<A NAME="IDX292"></A>
<DT><CODE>bool getRecord( sc_Record &#38; record )</CODE>
<DD><A NAME="IDX293"></A>
Set <VAR>record</VAR> from the current builder module object.
<P>

<A NAME="IDX294"></A>
<DT><CODE>bool setRecord( sc_Record const &#38; record )</CODE>
<DD><A NAME="IDX295"></A>
Populate the builder module object based on the fields and subfield
values in <VAR>record</VAR>.  Return false if the record fields don't
contain proper data associated with that specific builder module;
e.g., trying to set an IDEN builder module from an sc_Record with CATD
field and subfield values.
<P>

<A NAME="IDX296"></A>
<DT><CODE>emitRecIdenField( bool )</CODE>
<DD><A NAME="IDX297"></A>
Indicate whether the builder module should create ISO 8211 records
with the optional ISO 8211 record identifier field.  Note, setting
this field is optional, and actually contains redundant information.
Therefore it's not recommended to emit ISO 8211 record identifier
fields when creating SDTS modules.
<P>

</DL>
<P>

Additionally, each builder class has three sets of methods, one for
setting module specific field/subfield values, one for getting same,
and the third for "unsetting" values.  Moreover, each of those
methods, in turn, have long name and mnemonic versions.
</P><P>

For example, the following two functions are equivalent members of <CODE>sb_Ldef</CODE>:
</P><P>

<DL COMPACT>
<DT><CODE>bool sb_Ldef::getLayerLabel( string &#38; ) const;</CODE>
<DD><DT><CODE>bool sb_Ldef::getLLBL( string &#38; ) const;</CODE>
<DD></DL>
<P>

They have semantic inverses of:
</P><P>

<DL COMPACT>
<DT><CODE>bool setLayerLabel( std::string const&#38; val );</CODE>
<DD><DT><CODE>bool setLLBL( std::string const&#38; val );</CODE>
<DD></DL>
<P>

There is also a third set:
</P><P>

<DL COMPACT>
<DT><CODE>void unDefineLayerLabel( );</CODE>
<DD><DT><CODE>void unDefineLLBL( );</CODE>
<DD></DL>
<P>

These last set of functions set the corresponding sc_Subfield to
"undefined".  (That is, a NULL, or empty, value.)
</P><P>

Examples of use can be found in <TT>`tests/sb*t.cpp'</TT>.
</P><P>

<A NAME="Binary Converter Builder"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.2 Binary Converter Builder </H3>
<!--docid::SEC33::-->
<P>

There exists in <TT>`sdts++/builder/sb_Utils.h'</TT>:
</P><P>

<A NAME="IDX298"></A>
<DL>
<DT><U>Method:</U> sb_Utils <B>addConverters</B> <I>catd-fn converters</I>
<DD></P><P>

Takes a string <VAR>catd-fn</VAR> that contains an SDTS CATD module
filename, and <VAR>converters</VAR> which is a binary converter table, and
does all the necessary module look-ups to populate the binary
converters.  This includes looking up coordinate binary types in the
IREF and DDSH modules found via the given CATD module.  Returns true
if successfully populated the binary converts, false otherwise.
</P><P>

</DL>
</P><P>

An example of use can be found in <TT>`tests/sb_Directory_t.cpp'</TT>.
</P><P>

<A NAME="sb_Directory"></A>
<HR SIZE="6">
<A NAME="SEC34"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC33"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC35"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.3 sb_Directory </H3>
<!--docid::SEC34::-->
<P>

<CODE>sb_Directory</CODE>, found in <TT>`sdts++/builder/sb_Catd.h'</TT>,
provides a mechanism for looking up SDTS CATD module information.
</P><P>

<DL COMPACT>
<A NAME="IDX299"></A>
<DT><CODE>sb_Directory::sb_Directory()</CODE>
<DD><A NAME="IDX300"></A>
<A NAME="IDX301"></A>
<DT><CODE>sb_Directory::sb_Directory( string const &#38; catd_filename )</CODE>
<DD><A NAME="IDX302"></A>
Creates <CODE>sb_Directory</CODE> class; optional <VAR>catd_filename</VAR> specifies location of SDTS catalog module.
<P>

<A NAME="IDX303"></A>
<DT><CODE>bool sb_Directory::find( string const &#38; module_name, sb_Catd &#38; module info )</CODE>
<DD><A NAME="IDX304"></A>
Looks for <VAR>module_name</VAR> in currently loaded CATD.  If found, sets
the given <CODE>sb_Catd</CODE> record to values for that module, and returns
true; otherwise, it returns false.  The <CODE>sb_Catd</CODE> object can be
used to query the file name of the given module.
<P>

<A NAME="IDX305"></A>
<DT><CODE>bool sb_Directory::catdFilename( string const &#38; filename )</CODE>
<DD><A NAME="IDX306"></A>
Tells the <CODE>sb_Directory</CODE> object to load up the CATD module found
at <VAR>filename</VAR> in preparation for <CODE>find()</CODE> calls.
<P>

</DL>
<P>

<A NAME="sb_Accessor"></A>
<HR SIZE="6">
<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC34"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC12"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 3.3.4 sb_Accessor </H3>
<!--docid::SEC35::-->
<P>

<CODE>sb_Accessor</CODE>, which is found in
<TT>`sdts++/builder/sb_Accessor.h'</TT>, is a convenience class for
accessing arbitrary SDTS modules and records without having to open up
each module by hand.  The CATD module is used to find a dataset's
modules.
</P><P>

<DL COMPACT>
<A NAME="IDX307"></A>
<DT><CODE>sb_Accessor()</CODE>
<DD><A NAME="IDX308"></A>
<A NAME="IDX309"></A>
<DT><CODE>sb_Accessor( string const &#38; catd_fn )</CODE>
<DD><A NAME="IDX310"></A>
Create an <CODE>sb_Accessor</CODE>, optionally with <VAR>catd_fn</VAR> that
specifies the file name of a CATD module.
<P>

<A NAME="IDX311"></A>
<DT><CODE>bool sb_Accessor::readCatd( string const &#38; catd_fn )</CODE>
<DD><A NAME="IDX312"></A>
Open and read the given CATD module specified in the <VAR>catd_fn</VAR>;
return true if successfully read, otherwise false.
<P>

<A NAME="IDX313"></A>
<DT><CODE>string &#38; sb_Accessor::fileName() const;</CODE>
<DD><A NAME="IDX314"></A>
Return the current CATD module file name.
<P>

<A NAME="IDX315"></A>
<DT><CODE>bool sb_Accesssor::get( sb_Module &#38; module, sio_8211_converter_dictionary* cv = 0x0 );</CODE>
<DD><A NAME="IDX316"></A>
Use the CATD information to find the corresponding <VAR>module</VAR> file,
open it, read in the first record, and then use that record to
populate the given module.  This will return false if there are no
more records, the SDTS module file didn't exist, or there were some
I/O or resource problems.  (E.g., out of memory or a corrupted
module.)  Will return true if the module was successfully populated.
This can be invoked multiple times for modules with more than one
record; again get() will return false if all the module records have
been read. The optional converter parameter is used to provide
appropriate hints for reading binary data.
<P>

</DL>
<P>

Note that this currently only handles single instances of a given
module type since the internal <CODE>sb_Accessor</CODE> state tracks
uniquely by module type.  (E.g., there are generally more than one
instance of spatial modules, such as line, node, and polygon modules.)
So, this would be chiefly used as a convenience for trivially accessing
non-spatial and attribute modules.
</P><P>

An example of use can be found in <TT>`tests/sb_accessor_t.cpp'</TT>.
</P><P>

<A NAME="Logical Classes"></A>
<HR SIZE="6">
<A NAME="SEC36"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC35"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC37"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC31"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC37"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 3.4 Logical Classes </H2>
<!--docid::SEC36::-->
<P>

These provide basic spatial primitive classes corresponding to the
SDTS logical spatial model specification, and are found in <TT>`sdts++/logical'</TT>.
</P><P>

<DL COMPACT>
<DT><TT>`sl_Object.h'</TT>
<DD>SDTS logical abstract base class
<P>

<DT><TT>`sl_Point.h'</TT>
<DD>SDTS points
<P>

<DT><TT>`sl_Node.h'</TT>
<DD>SDTS nodes
<P>

<DT><TT>`sl_Chain.h'</TT>
<DD>SDTS chains
<P>

<DT><TT>`sl_String.h'</TT>
<DD>SDTS strings
<P>

<DT><TT>`sl_Ring.h'</TT>
<DD>SDTS rings
<P>

<DT><TT>`sl_Polygon.h'</TT>
<DD>SDTS polygons
<P>

</DL>
<P>

<A NAME="Credits"></A>
<HR SIZE="6">
<A NAME="SEC37"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC36"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC38"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC5"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC38"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 4. Credits </H1>
<!--docid::SEC37::-->
<P>

SDTS++ was developed at the United States Geological Survey's
Mid-Continent Mapping Center's Software Engineering Section in Rolla,
Missouri.
</P><P>

<DL COMPACT>
<DT><I>Principal Architects:</I>
<DD>Jamie Moyers (USGS) and Mark Coletti (SAIC)
<P>

<DT><I>Lead Programmers:</I>
<DD>Jamie Moyers (USGS) and Mark Coletti (SAIC)
<P>

<DT><I>Programming:</I>
<DD>Dave Edwards (SAIC), Justin Ferguson (USGS), Chad Slaughter (USGS),
James Morgan (SAIC), Shonie Maxwell (USGS)
<P>

<DT><I>Documentation:</I>
<DD>Mark Coletti (SAIC), James Morgan (SAIC), Shonie Maxwell (USGS)
<P>

<DT><I>Special Thanks To:</I>
<DD>Dr. Rong Li (Keane Federal Systems), Greg Martin (USGS), Mike Childs
(USGS), Paul Gray (USGS), Andrew Arensburger (UMD), David Hensinger
(Sandia National Labs), Steven Zhou, Bob Weber, Tim Fitzgerald, Frank
Warmerdam, David Weller, Alexander Gavrilov <A HREF="mailto:angavrilov@home.com">angavrilov@home.com</A>,
Vandam <A HREF="mailto:vandam@ispc1.auto.inha.ac.kr">vandam@ispc1.auto.inha.ac.kr</A>, 
Michal Kracik <A HREF="mailto:kracik@mbox.dkm.cz">kracik@mbox.dkm.cz</A>, 
Daniel S Custer <A HREF="mailto:dscuster@usgs.gov">dscuster@usgs.gov</A>, Todd Sprague <A HREF="mailto:todd@pcavionics.com">todd@pcavionics.com</A>
<P>

<DT><I>Running Interference:</I>
<DD>Phyllis Altheide (USGS), Larry Moore (USGS)
</DL>
<P>

<A NAME="Legalese"></A>
<HR SIZE="6">
<A NAME="SEC38"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC37"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC39"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC37"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC39"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 5. Legalese </H1>
<!--docid::SEC38::-->
<P>

The SDTS++ toolkit was written by employees and contractors of the
U.S. Geological Survey.  The USGS writes software to support
government research and data production operations, not to provide
free alternatives to commercial software.  The SDTS++ toolkit is
placed in the public domain in the spirit of sharing the results of
scientific research. The library is not an official USGS product, is
not commercial-grade software, is not guaranteed to be appropriate for
all SDTS applications, and is not supported.  We invite user comments
and suggestions, and will act on them as resources and as other
priorities permit.  However, the availability of this software does
not imply any USGS committment to fix reported bugs, provide
documentation, or assist other organizations in learning to use the
toolkit.
</P><P>

Neither the U.S. Government nor any agency thereof nor any of their
employees make any warranty, expressed or implied, or assume any legal
responsibility for the accuracy, completeness, or usefulness of any
information, apparatus, product, or process disclosed herein or
represent that its use would not infringe privately owned
rights. Reference to any specific commercial product, process, or
service by trade name, trademark, manufacturer, or otherwise does not
necessarily constitute or imply its endorsement, recommendation, or
favoring by the U.S. Government or any agency thereof.
</P><P>

<A NAME="Support"></A>
<HR SIZE="6">
<A NAME="SEC39"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC38"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC40"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC38"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC40"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Support </H1>
<!--docid::SEC39::-->
<P>

<A NAME="IDX317"></A>
<A NAME="IDX318"></A>
</P><P>

There is no technical support for SDTS++.  However, there is a mailing
list for SDTS related software.  One purpose of this list is to
provide peer support for SDTS software development efforts.  Some of
the SDTS++ development team subscribe to this list and _may_ address
problems related to the toolkit.  After all, if you're having problems
with the library, chances are they are having the same problems, too.
</P><P>

You can subscribe to this list by sending e-mail to
<A HREF="mailto:majordomo@mailrmon1.er.usgs.gov">majordomo@mailrmon1.er.usgs.gov</A> with this line in the body of the
message:
</P><P>

subscribe sdts_software <A HREF="mailto:myname@my.host">myname@my.host</A>
</P><P>

Substitute your e-mail address for <A HREF="mailto:myname@my.host">myname@my.host</A>.  So I'd put in:
</P><P>

subscribe sdts_software <A HREF="mailto:mcoletti@lychnobite.org">mcoletti@lychnobite.org</A>
</P><P>

... if I wanted to subscribe to the mailing list.  DO NOT USE <A HREF="mailto:myhname@my.host">myhname@my.host</A>.
</P><P>

"sdts_software" is a technical discussion list.  There is no guarantee
that questions posted to this list will be answered.  General
information about SDTS should be requested by sending mail to
<A HREF="mailto:sdts@usgs.gov">sdts@usgs.gov</A>.  <A HREF="mailto:sdts@usgs.gov">sdts@usgs.gov</A> is also a public mailing
list, but it is monitored by USGS personnel.  Questions sent to it will
receive a response.
</P><P>

<A NAME="Bibliography"></A>
<HR SIZE="6">
<A NAME="SEC40"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC39"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC39"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 7. Bibliography </H1>
<!--docid::SEC40::-->
<P>

FIPS-173, Spatial Data Transfer Standard, ANSI.
</P><P>

ISO 8211:1994(E), ISO/IEC, Geneva, Switzerland.
</P><P>

STL Tutorial and Reference Guide, Musser &#38; Saini, Addison-Wesley, 1996.
</P><P>

<A NAME="Concept Index"></A>
<HR SIZE="6">
<A NAME="SEC41"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC40"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC40"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[ &gt;&gt; ]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> Concept Index </H1>
<!--docid::SEC41::-->
     
<table><tr><th valign=top>Jump to: &nbsp; </th><td><A HREF="sdts++.html#cp_~" style="text-decoration:none"><b>~</b></A>
 &nbsp; 
<BR>
<A HREF="sdts++.html#cp_A" style="text-decoration:none"><b>A</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_B" style="text-decoration:none"><b>B</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_C" style="text-decoration:none"><b>C</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_D" style="text-decoration:none"><b>D</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_F" style="text-decoration:none"><b>F</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_I" style="text-decoration:none"><b>I</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_L" style="text-decoration:none"><b>L</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_M" style="text-decoration:none"><b>M</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_R" style="text-decoration:none"><b>R</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_S" style="text-decoration:none"><b>S</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_T" style="text-decoration:none"><b>T</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_U" style="text-decoration:none"><b>U</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_V" style="text-decoration:none"><b>V</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_W" style="text-decoration:none"><b>W</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_X" style="text-decoration:none"><b>X</b></A>
 &nbsp; 
</td></tr></table><br><P></P>
<TABLE border=0>
<TR><TD></TD><TH ALIGN=LEFT>Index Entry</TH><TH ALIGN=LEFT> Section</TH></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_~"></A>~</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX82"><CODE>~sc_Subfield()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX83"><CODE>~sc_Subfield()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX220"><CODE>~sio_8211FieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX221"><CODE>~sio_8211FieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX176"><CODE>~sio_8211Reader()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX177"><CODE>~sio_8211Reader()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX256"><CODE>~sio_8211SubfieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX257"><CODE>~sio_8211SubfieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX202"><CODE>~sio_8211Writer()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX203"><CODE>~sio_8211Writer()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX16"><CODE>~X()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX17"><CODE>~X()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_A"></A>A</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX18"><CODE>a.begin()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX19"><CODE>a.begin()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX30"><CODE>a.empty()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX31"><CODE>a.empty()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX20"><CODE>a.end()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX21"><CODE>a.end()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX28"><CODE>a.max_size()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX29"><CODE>a.max_size()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX22"><CODE>a.rbegin()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX23"><CODE>a.rbegin()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX24"><CODE>a.rend()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX25"><CODE>a.rend()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX26"><CODE>a.size()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX27"><CODE>a.size()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX34"><CODE>a.swap(b)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX35"><CODE>a.swap(b)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX298"><CODE>addConverters on sb_Utils</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC33">3.3.2 Binary Converter Builder</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_B"></A>B</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX186"><CODE>bool done() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX187"><CODE>bool done() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX208"><CODE>bool emitDDR()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX209"><CODE>bool emitDDR()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX182"><CODE>bool get( sc_Record&#38;#38; record )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX183"><CODE>bool get( sc_Record&#38;#38; record )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX100"><CODE>bool getA(string&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX101"><CODE>bool getA(string&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX112"><CODE>bool getBI16(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX113"><CODE>bool getBI16(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX114"><CODE>bool getBI24(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX115"><CODE>bool getBI24(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX116"><CODE>bool getBI32(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX117"><CODE>bool getBI32(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX110"><CODE>bool getBI8(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX111"><CODE>bool getBI8(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX120"><CODE>bool getBUI16(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX121"><CODE>bool getBUI16(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX122"><CODE>bool getBUI24(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX123"><CODE>bool getBUI24(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX124"><CODE>bool getBUI32(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX125"><CODE>bool getBUI32(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX118"><CODE>bool getBUI8(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX119"><CODE>bool getBUI8(unsigned long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX108"><CODE>bool getC(string&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX109"><CODE>bool getC(string&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX126"><CODE>bool getFP32(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX127"><CODE>bool getFP32(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX128"><CODE>bool getFP64(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX129"><CODE>bool getFP64(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX102"><CODE>bool getI(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX103"><CODE>bool getI(long&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX104"><CODE>bool getR(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX105"><CODE>bool getR(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX106"><CODE>bool getS(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX107"><CODE>bool getS(double&#38;#38; val) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX212"><CODE>bool good( ) const;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX213"><CODE>bool good( ) const;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX236"><CODE>bool isRepeating() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX237"><CODE>bool isRepeating() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX88"><CODE>bool operator!=(sc_Subfield const&#38;#38; right) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX89"><CODE>bool operator!=(sc_Subfield const&#38;#38; right) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX86"><CODE>bool operator==(sc_Subfield const&#38;#38; right) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX87"><CODE>bool operator==(sc_Subfield const&#38;#38; right) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX210"><CODE>bool put( sc_Record&#38;#38; record )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX211"><CODE>bool put( sc_Record&#38;#38; record )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX8">Building</A></TD><TD valign=top><A HREF="sdts++.html#SEC2">2. Installing</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_C"></A>C</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX268"><CODE>char getDelimiter() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX269"><CODE>char getDelimiter() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX232"><CODE>char getFieldTerm( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX233"><CODE>char getFieldTerm( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX234"><CODE>char getUnitTerm( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX235"><CODE>char getUnitTerm( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX191">Creating Modules</A></TD><TD valign=top><A HREF="sdts++.html#SEC20">3.2.2 Writers</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_D"></A>D</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX224"><CODE>data_struct_code getDataStructCode( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX225"><CODE>data_struct_code getDataStructCode( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX226"><CODE>data_type_code getDataTypeCode( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX227"><CODE>data_type_code getDataTypeCode( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_F"></A>F</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX264"><CODE>format getFormat() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX265"><CODE>format getFormat() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_I"></A>I</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX7">Installing</A></TD><TD valign=top><A HREF="sdts++.html#SEC2">2. Installing</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX266"><CODE>int getLength() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX267"><CODE>int getLength() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX2">Introduction</A></TD><TD valign=top><A HREF="sdts++.html#SEC1">1. Introduction</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_L"></A>L</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX9">Library Organization</A></TD><TD valign=top><A HREF="sdts++.html#SEC5">3. Using</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_M"></A>M</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX318">mailing list</A></TD><TD valign=top><A HREF="sdts++.html#SEC39">6. Support</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_R"></A>R</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX32"><CODE>r = a</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX33"><CODE>r = a</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_S"></A>S</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX84"><CODE>sc_Subfield&#38;#38; operator=(sc_Subfield const&#38;#38; right)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX85"><CODE>sc_Subfield&#38;#38; operator=(sc_Subfield const&#38;#38; right)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX78"><CODE>sc_Subfield( )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX79"><CODE>sc_Subfield( )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX80"><CODE>sc_Subfield( sc_Subfield const&#38;#38; right)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX81"><CODE>sc_Subfield( sc_Subfield const&#38;#38; right)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX1">SDTS</A></TD><TD valign=top><A></A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX270"><CODE>sio_8211Converter const * getConverter() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX271"><CODE>sio_8211Converter const * getConverter() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX222"><CODE>sio_8211FieldFormat&#38;#38; operator=( sio_8211FieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX223"><CODE>sio_8211FieldFormat&#38;#38; operator=( sio_8211FieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX218"><CODE>sio_8211FieldFormat( sio_8211FieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX219"><CODE>sio_8211FieldFormat( sio_8211FieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX216"><CODE>sio_8211FieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX217"><CODE>sio_8211FieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX180"><CODE>sio_8211ForwardIterator( sio_8211Reader&#38;#38; reader )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX181"><CODE>sio_8211ForwardIterator( sio_8211Reader&#38;#38; reader )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX174"><CODE>sio_8211Reader( istream &#38;#38; is,  const map&#38;#60;string, sio_8211Converter*&#38;#62; * converters = 0)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX175"><CODE>sio_8211Reader( istream &#38;#38; is,  const map&#38;#60;string, sio_8211Converter*&#38;#62; * converters = 0)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX178"><CODE>sio_8211Schema &#38;#38; getSchema()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX179"><CODE>sio_8211Schema &#38;#38; getSchema()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX258"><CODE>sio_8211SubfieldFormat&#38;#38; operator=( sio_8211SubfieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX259"><CODE>sio_8211SubfieldFormat&#38;#38; operator=( sio_8211SubfieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX254"><CODE>sio_8211SubfieldFormat( sio_8211SubfieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX255"><CODE>sio_8211SubfieldFormat( sio_8211SubfieldFormat const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX252"><CODE>sio_8211SubfieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX253"><CODE>sio_8211SubfieldFormat()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX200"><CODE>sio_8211Writer( ofstream &#38;#38; ofs, const char* title )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX201"><CODE>sio_8211Writer( ofstream &#38;#38; ofs, const char* title )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX198"><CODE>sio_8211Writer( ofstream &#38;#38; ofs, const char* title, sio_8211Schema const &#38;#38; schema )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX199"><CODE>sio_8211Writer( ofstream &#38;#38; ofs, const char* title, sio_8211Schema const &#38;#38; schema )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX160"><CODE>sio_Reader( istream &#38;#38; is )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX161"><CODE>sio_Reader( istream &#38;#38; is )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX4">Standard Template Library</A></TD><TD valign=top><A HREF="sdts++.html#SEC1">1. Introduction</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX3">STL</A></TD><TD valign=top><A HREF="sdts++.html#SEC1">1. Introduction</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX230"><CODE>string const&#38;#38;     getName( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX231"><CODE>string const&#38;#38;     getName( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX260"><CODE>string const&#38;#38; getLabel() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX261"><CODE>string const&#38;#38; getLabel() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX38"><CODE>string const&#38;#38; getMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX39"><CODE>string const&#38;#38; getMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX94"><CODE>string const&#38;#38; getMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX95"><CODE>string const&#38;#38; getMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX36"><CODE>string const&#38;#38; getName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX37"><CODE>string const&#38;#38; getName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX92"><CODE>string const&#38;#38; getName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX93"><CODE>string const&#38;#38; getName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX228"><CODE>string const&#38;#38; getTag( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX229"><CODE>string const&#38;#38; getTag( ) const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX42"><CODE>string const&#38;#38; setMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX43"><CODE>string const&#38;#38; setMnemonic() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX98"><CODE>string const&#38;#38; setMnemonic(string const&#38;#38; mnem)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX99"><CODE>string const&#38;#38; setMnemonic(string const&#38;#38; mnem)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX40"><CODE>string const&#38;#38; setName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX41"><CODE>string const&#38;#38; setName() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX96"><CODE>string const&#38;#38; setName(string const&#38;#38; name)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX97"><CODE>string const&#38;#38; setName(string const&#38;#38; name)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX90"><CODE>SubfieldType getSubfieldType() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX91"><CODE>SubfieldType getSubfieldType() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX317">support</A></TD><TD valign=top><A HREF="sdts++.html#SEC39">6. Support</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_T"></A>T</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX262"><CODE>type getType() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX263"><CODE>type getType() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_U"></A>U</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX5">UNIX</A></TD><TD valign=top><A HREF="sdts++.html#SEC2">2. Installing</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_V"></A>V</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX170"><CODE>virtual bool done() const = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX171"><CODE>virtual bool done() const = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX166"><CODE>virtual bool get( sc_Record&#38;#38; record )  = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX167"><CODE>virtual bool get( sc_Record&#38;#38; record )  = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX196"><CODE>virtual bool good( ) const = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX197"><CODE>virtual bool good( ) const = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX194"><CODE>virtual bool put( sc_Record&#38;#38; ) = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX195"><CODE>virtual bool put( sc_Record&#38;#38; ) = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX188"><CODE>virtual operator void*() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX189"><CODE>virtual operator void*() const</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX172"><CODE>virtual operator void*() const = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX173"><CODE>virtual operator void*() const = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX168"><CODE>virtual void operator++() = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX169"><CODE>virtual void operator++() = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX164"><CODE>virtual ~sio_ForwardIterator( )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX165"><CODE>virtual ~sio_ForwardIterator( )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX162"><CODE>virtual ~sio_Reader() = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX163"><CODE>virtual ~sio_Reader() = 0;</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX192"><CODE>virtual ~sio_Writer() = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX193"><CODE>virtual ~sio_Writer() = 0</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX6">Visual C++</A></TD><TD valign=top><A HREF="sdts++.html#SEC2">2. Installing</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX184"><CODE>void operator++()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX185"><CODE>void operator++()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX214"><CODE>void reuseLeaderAndDirectory()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX215"><CODE>void reuseLeaderAndDirectory()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX130"><CODE>void setA(string const&#38;#38; val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX131"><CODE>void setA(string const&#38;#38; val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX142"><CODE>void setBI16(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX143"><CODE>void setBI16(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX144"><CODE>void setBI24(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX145"><CODE>void setBI24(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX146"><CODE>void setBI32(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX147"><CODE>void setBI32(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX140"><CODE>void setBI8(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX141"><CODE>void setBI8(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX150"><CODE>void setBUI16(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX151"><CODE>void setBUI16(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX152"><CODE>void setBUI24(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX153"><CODE>void setBUI24(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX154"><CODE>void setBUI32(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX155"><CODE>void setBUI32(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX148"><CODE>void setBUI8(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX149"><CODE>void setBUI8(unsigned long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX138"><CODE>void setC(string const&#38;#38; val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX139"><CODE>void setC(string const&#38;#38; val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX282"><CODE>void setConverter( sio_8211Converter const * )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX283"><CODE>void setConverter( sio_8211Converter const * )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX238"><CODE>void setDataStructCode( data_struct_code )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX239"><CODE>void setDataStructCode( data_struct_code )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX240"><CODE>void setDataTypeCode( data_type_code )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX241"><CODE>void setDataTypeCode( data_type_code )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX280"><CODE>void setDelimiter( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX281"><CODE>void setDelimiter( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX246"><CODE>void setFieldTerm( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX247"><CODE>void setFieldTerm( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX204"><CODE>void setFileTitle( const char* fn )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX205"><CODE>void setFileTitle( const char* fn )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX276"><CODE>void setFormat( format )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX277"><CODE>void setFormat( format )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX156"><CODE>void setFP32(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX157"><CODE>void setFP32(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX158"><CODE>void setFP64(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX159"><CODE>void setFP64(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX132"><CODE>void setI(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX133"><CODE>void setI(long val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX250"><CODE>void setIsRepeating( bool repeating )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX251"><CODE>void setIsRepeating( bool repeating )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX272"><CODE>void setLabel( string const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX273"><CODE>void setLabel( string const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX278"><CODE>void setLength( int )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX279"><CODE>void setLength( int )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX244"><CODE>void setName( string const&#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX245"><CODE>void setName( string const&#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX134"><CODE>void setR(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX135"><CODE>void setR(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX136"><CODE>void setS(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX137"><CODE>void setS(double val)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX206"><CODE>void setSchema( sio_8211Schema const &#38;#38; schema )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX207"><CODE>void setSchema( sio_8211Schema const &#38;#38; schema )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX242"><CODE>void setTag( string const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX243"><CODE>void setTag( string const &#38;#38; )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX274"><CODE>void setType( type )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX275"><CODE>void setType( type )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX248"><CODE>void setUnitTerm( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX249"><CODE>void setUnitTerm( char )</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_W"></A>W</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX190">Writers</A></TD><TD valign=top><A HREF="sdts++.html#SEC20">3.2.2 Writers</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
<TR><TH><A NAME="cp_X"></A>X</TH><TD></TD><TD></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX14"><CODE>X u(a)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX15"><CODE>X u(a)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX10"><CODE>X()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX11"><CODE>X()</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX12"><CODE>X(a)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD></TD><TD valign=top><A HREF="sdts++.html#IDX13"><CODE>X(a)</CODE></A></TD><TD valign=top><A HREF="sdts++.html#SEC7">3.1.1 Container interface</A></TD></TR>
<TR><TD COLSPAN=3> <HR></TD></TR>
</TABLE><P></P><table><tr><th valign=top>Jump to: &nbsp; </th><td><A HREF="sdts++.html#cp_~" style="text-decoration:none"><b>~</b></A>
 &nbsp; 
<BR>
<A HREF="sdts++.html#cp_A" style="text-decoration:none"><b>A</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_B" style="text-decoration:none"><b>B</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_C" style="text-decoration:none"><b>C</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_D" style="text-decoration:none"><b>D</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_F" style="text-decoration:none"><b>F</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_I" style="text-decoration:none"><b>I</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_L" style="text-decoration:none"><b>L</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_M" style="text-decoration:none"><b>M</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_R" style="text-decoration:none"><b>R</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_S" style="text-decoration:none"><b>S</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_T" style="text-decoration:none"><b>T</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_U" style="text-decoration:none"><b>U</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_V" style="text-decoration:none"><b>V</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_W" style="text-decoration:none"><b>W</b></A>
 &nbsp; 
<A HREF="sdts++.html#cp_X" style="text-decoration:none"><b>X</b></A>
 &nbsp; 
</td></tr></table><br>     
<HR SIZE="6">
<A NAME="SEC_Contents"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Table of Contents</H1>
<UL>
<A NAME="TOC1" HREF="sdts++.html#SEC1">1. Introduction</A>
<BR>
<A NAME="TOC2" HREF="sdts++.html#SEC2">2. Installing</A>
<BR>
<UL>
<A NAME="TOC3" HREF="sdts++.html#SEC3">2.1 Installing for Windows</A>
<BR>
<A NAME="TOC4" HREF="sdts++.html#SEC4">2.2 Installing for UNIX</A>
<BR>
</UL>
<A NAME="TOC5" HREF="sdts++.html#SEC5">3. Using</A>
<BR>
<UL>
<A NAME="TOC6" HREF="sdts++.html#SEC6">3.1 Container Classes</A>
<BR>
<UL>
<A NAME="TOC7" HREF="sdts++.html#SEC7">3.1.1 Container interface</A>
<BR>
<UL>
<A NAME="TOC8" HREF="sdts++.html#SEC8">3.1.1.1 sc_Module</A>
<BR>
<A NAME="TOC9" HREF="sdts++.html#SEC9">3.1.1.2 sc_Record</A>
<BR>
<A NAME="TOC10" HREF="sdts++.html#SEC10">3.1.1.3 sc_Field</A>
<BR>
<A NAME="TOC11" HREF="sdts++.html#SEC11">3.1.1.4 sc_Subfield</A>
<BR>
</UL>
</UL>
<A NAME="TOC12" HREF="sdts++.html#SEC12">3.2 I/O Classes</A>
<BR>
<UL>
<A NAME="TOC13" HREF="sdts++.html#SEC13">3.2.1 Readers</A>
<BR>
<UL>
<A NAME="TOC14" HREF="sdts++.html#SEC14">3.2.1.1 Reader and Reader Iterator Base Classes</A>
<BR>
<A NAME="TOC15" HREF="sdts++.html#SEC15">3.2.1.2 sio_Reader</A>
<BR>
<A NAME="TOC16" HREF="sdts++.html#SEC16">3.2.1.3 sio_ForwardIterator</A>
<BR>
<A NAME="TOC17" HREF="sdts++.html#SEC17">3.2.1.4 sio_8211Reader</A>
<BR>
<A NAME="TOC18" HREF="sdts++.html#SEC18">3.2.1.5 8211 Forward Iterator</A>
<BR>
<A NAME="TOC19" HREF="sdts++.html#SEC19">3.2.1.6 Example</A>
<BR>
</UL>
<A NAME="TOC20" HREF="sdts++.html#SEC20">3.2.2 Writers</A>
<BR>
<UL>
<A NAME="TOC21" HREF="sdts++.html#SEC21">3.2.2.1 sio_Writer</A>
<BR>
<A NAME="TOC22" HREF="sdts++.html#SEC22">3.2.2.2 sio_8211Writer</A>
<BR>
<A NAME="TOC23" HREF="sdts++.html#SEC23">3.2.2.3 Schemas</A>
<BR>
<A NAME="TOC24" HREF="sdts++.html#SEC24">3.2.2.4 sio_8211FieldFormat</A>
<BR>
<A NAME="TOC25" HREF="sdts++.html#SEC25">3.2.2.5 sio_8211SubfieldFormat</A>
<BR>
<A NAME="TOC26" HREF="sdts++.html#SEC26">3.2.2.6 Repeating fields</A>
<BR>
<A NAME="TOC27" HREF="sdts++.html#SEC27">3.2.2.7 A note about repeating binary fields</A>
<BR>
<A NAME="TOC28" HREF="sdts++.html#SEC28">3.2.2.8 Support for permuted tags</A>
<BR>
<A NAME="TOC29" HREF="sdts++.html#SEC29">3.2.2.9 Dropped leaders and directories</A>
<BR>
<A NAME="TOC30" HREF="sdts++.html#SEC30">3.2.2.10 Example</A>
<BR>
</UL>
</UL>
<A NAME="TOC31" HREF="sdts++.html#SEC31">3.3 Builder Classes</A>
<BR>
<UL>
<A NAME="TOC32" HREF="sdts++.html#SEC32">3.3.1 Builder SDTS Module Classes</A>
<BR>
<A NAME="TOC33" HREF="sdts++.html#SEC33">3.3.2 Binary Converter Builder</A>
<BR>
<A NAME="TOC34" HREF="sdts++.html#SEC34">3.3.3 sb_Directory</A>
<BR>
<A NAME="TOC35" HREF="sdts++.html#SEC35">3.3.4 sb_Accessor</A>
<BR>
</UL>
<A NAME="TOC36" HREF="sdts++.html#SEC36">3.4 Logical Classes</A>
<BR>
</UL>
<A NAME="TOC37" HREF="sdts++.html#SEC37">4. Credits</A>
<BR>
<A NAME="TOC38" HREF="sdts++.html#SEC38">5. Legalese</A>
<BR>
<A NAME="TOC39" HREF="sdts++.html#SEC39">6. Support</A>
<BR>
<A NAME="TOC40" HREF="sdts++.html#SEC40">7. Bibliography</A>
<BR>
<A NAME="TOC41" HREF="sdts++.html#SEC41">Concept Index</A>
<BR>
</UL>
<HR SIZE=1>
<A NAME="SEC_OVERVIEW"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>Short Table of Contents</H1>
<BLOCKQUOTE>
<A NAME="TOC1" HREF="sdts++.html#SEC1">1. Introduction</A>
<BR>
<A NAME="TOC2" HREF="sdts++.html#SEC2">2. Installing</A>
<BR>
<A NAME="TOC5" HREF="sdts++.html#SEC5">3. Using</A>
<BR>
<A NAME="TOC37" HREF="sdts++.html#SEC37">4. Credits</A>
<BR>
<A NAME="TOC38" HREF="sdts++.html#SEC38">5. Legalese</A>
<BR>
<A NAME="TOC39" HREF="sdts++.html#SEC39">6. Support</A>
<BR>
<A NAME="TOC40" HREF="sdts++.html#SEC40">7. Bibliography</A>
<BR>
<A NAME="TOC41" HREF="sdts++.html#SEC41">Concept Index</A>
<BR>

</BLOCKQUOTE>
<HR SIZE=1>
<A NAME="SEC_About"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC41">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="sdts++.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1>About this document</H1>
This document was generated by <I>Mark Coletti</I> on <I>June, 10  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
<P></P>  
The buttons in the navigation panels have the following meaning:
<P></P>
<table border = "1">
<TR>
<TH> Button </TH>
<TH> Name </TH>
<TH> Go to </TH>
<TH> From 1.2.3 go to</TH>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &lt; ] </TD>
<TD ALIGN="CENTER">
Back
</TD>
<TD>
previous section in reading order
</TD>
<TD>
1.2.2
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &gt; ] </TD>
<TD ALIGN="CENTER">
Forward
</TD>
<TD>
next section in reading order
</TD>
<TD>
1.2.4
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &lt;&lt; ] </TD>
<TD ALIGN="CENTER">
FastBack
</TD>
<TD>
previous or up-and-previous section 
</TD>
<TD>
1.1
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ Up ] </TD>
<TD ALIGN="CENTER">
Up
</TD>
<TD>
up section
</TD>
<TD>
1.2
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ &gt;&gt; ] </TD>
<TD ALIGN="CENTER">
FastForward
</TD>
<TD>
next or up-and-next section
</TD>
<TD>
1.3
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Top] </TD>
<TD ALIGN="CENTER">
Top
</TD>
<TD>
cover (top) of document
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Contents] </TD>
<TD ALIGN="CENTER">
Contents
</TD>
<TD>
table of contents
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [Index] </TD>
<TD ALIGN="CENTER">
Index
</TD>
<TD>
concept index
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
 [ ? ] </TD>
<TD ALIGN="CENTER">
About
</TD>
<TD>
this page
</TD>
<TD>
 &nbsp; 
</TD>
</TR>
</TABLE>
<P></P>
where the <STRONG> Example </STRONG> assumes that the current position 
is at <STRONG> Subsubsection One-Two-Three </STRONG> of a document of 
the following structure:
<UL>
<LI> 1. Section One  </LI>
<UL>
<LI>1.1 Subsection One-One</LI>
<UL>
<LI> ... </LI>
</UL>
<LI>1.2 Subsection One-Two</LI>
<UL>
<LI>1.2.1 Subsubsection One-Two-One
</LI><LI>1.2.2 Subsubsection One-Two-Two
</LI><LI>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp; <STRONG>
&lt;== Current Position </STRONG>
</LI><LI>1.2.4 Subsubsection One-Two-Four
</LI></UL>
<LI>1.3 Subsection One-Three</LI>
<UL>
<LI> ... </LI>
</UL>
<LI>1.4 Subsection One-Four</LI>
</UL>
</UL>

<HR SIZE=1>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Mark Coletti</I> on <I>June, 10  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
